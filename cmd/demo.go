package main

import (
	"fmt"
	tls "gitlab.com/yawning/utls.git"
	gotls "crypto/tls"
	"golang.org/x/net/http2"
	"httpmod"
	"io"
	"net"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"time"
)

func main() {
	httpmod.Apply()

	httpmod.MaxHeaderListSize = 999999
	httpmod.TransportDefaultStreamFlow = 8888888

	err := httpWithKeylog("https://postman-echo.com/get", "/tmp/banaan.txt")
	if err != nil {
		panic(err)
	}

	//demoPlain("https://www.cloudflare.com/")
	//demoPlain("http://postman-echo.com/get")
	//demoProxyied("https://www.genx.co.nz/")
	//demoProxyied("https://httpbin.org/anything")
	//demoProxyied("https://ja3er.com/json")
	//demoProxyied("https://client.tlsfingerprint.io:8443/")
}

func demoProxyied(target string) {
	proxyUrl, err := url.Parse("http://107.161.50.58:7603/")
	if err != nil {
		panic(err)
	}

	tripper, err := httpmod.NewUTLSRoundTripper(&tls.HelloFirefox_Auto, nil, proxyUrl)
	httpClient := &http.Client{
		Transport: tripper,
	}

	req, err := http.NewRequest(http.MethodGet, target, nil)
	if err != nil {
		panic(err)
	}

	oh := make(httpmod.OrderedHeader)
	oh.Add("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
	oh.Add("Accept-Encoding", "gzip, deflate")
	oh.Add("Accept-Language", "en-GB,en;q=0.5")
	oh.Add("Upgrade-Insecure-Requests", "1")
	oh.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36")

	req.Header = http.Header(oh)


	r, err := httpClient.Do(req)
	if err != nil {
		panic(err)
	}

	rb, err := httputil.DumpResponse(r, true)
	if err != nil {
		panic(err)
	}

	fmt.Println(string(rb))
}

func demoPlain(target string) {

	tripper, err := httpmod.NewUTLSRoundTripper(&tls.HelloFirefox_Auto, nil, nil)
	httpClient := &http.Client{
		Transport: tripper,
	}
	req, err := http.NewRequest(http.MethodGet, target, nil)
	if err != nil {
		panic(err)
	}

	oh := make(httpmod.OrderedHeader)
	oh.Add("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
	oh.Add("Accept-Encoding", "gzip, deflate")
	oh.Add("Accept-Language", "en-GB,en;q=0.5")
	oh.Add("SUP", "HEY")
	oh.Add("Upgrade-Insecure-Requests", "1")
	oh.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/82.0.4183.121 Safari/537.36")

	req.Header = http.Header(oh)

	r, err  := httpClient.Do(req)
	if err != nil {
		panic(err)
	}

	rb, err := httputil.DumpResponse(r, true)
	if err != nil {
		panic(err)
	}

	fmt.Println(string(rb))
}


func httpWithKeylog(url, keyLogFileName string) error {
	kl, err := os.OpenFile(keyLogFileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	fmt.Fprintf(kl, "# SSL/TLS secrets log file, generated by go\n")

	client := http.Client{Transport: newTransportWithKeyLog(kl)}

	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return err
	}
	if req.URL.Scheme != "https" {
		return fmt.Errorf("URL must start with https://")
	}
	fmt.Printf("Leaking TLS keys to %s\n----------------------\n", keyLogFileName)

	headers := make(httpmod.OrderedHeader)
	headers.Add("SUP", "HEY")
	headers.Add("NON-Ordered", "VALUE")

	req.Header = http.Header(headers)

	res, err := client.Do(req)
	if err != nil {
		return err
	}
	dump, err := httputil.DumpResponse(res, true)
	if err != nil {
		return err
	}
	fmt.Println(string(dump))
	return nil
}

// newTransportWithKeyLog initializes a HTTP Transport with KeyLogWriter
func newTransportWithKeyLog(keyLog io.Writer) *http.Transport {
	transport := &http.Transport{
		TLSClientConfig: &gotls.Config{KeyLogWriter: keyLog},

		// Copy of http.DefaultTransport
		Proxy: http.ProxyFromEnvironment,
		DialContext: (&net.Dialer{
			Timeout:   30 * time.Second,
			KeepAlive: 30 * time.Second,
			DualStack: true,
		}).DialContext,
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
	}
	if err := http2.ConfigureTransport(transport); err != nil {
		panic(err)
	}
	return transport
}