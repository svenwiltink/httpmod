package main

import (
	gotls "crypto/tls"
	"fmt"
	"golang.org/x/net/http2"
	"httpmod"
	"io"
	"net"
	"net/http"
	"net/http/httputil"
	"os"
	"time"
)

func main() {
	httpmod.Apply()

	httpmod.InitialHeaderTableSize = 10485760
	httpmod.MaxHeaderListSize = 65536
	httpmod.TransportDefaultStreamFlow = 6291456
	httpmod.MaxConcurrentStreams = 1000
	httpmod.SettingEnablePush = 0
	httpmod.MaxFrameSize = 16384

	err := httpWithKeylog("https://postman-echo.com/get", "/tmp/banaan.txt")
	if err != nil {
		panic(err)
	}

}

func httpWithKeylog(url, keyLogFileName string) error {
	kl, err := os.OpenFile(keyLogFileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	fmt.Fprintf(kl, "# SSL/TLS secrets log file, generated by go\n")

	client := http.Client{Transport: newTransportWithKeyLog(kl)}

	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return err
	}
	if req.URL.Scheme != "https" {
		return fmt.Errorf("URL must start with https://")
	}
	fmt.Printf("Leaking TLS keys to %s\n----------------------\n", keyLogFileName)

	headers := make(httpmod.OrderedHeader)
	headers.Add("SUP", "HEY")
	headers.Add("NON-Ordered", "VALUE")

	req.Header = http.Header(headers)

	res, err := client.Do(req)
	if err != nil {
		return err
	}
	dump, err := httputil.DumpResponse(res, true)
	if err != nil {
		return err
	}
	fmt.Println(string(dump))
	return nil
}

// newTransportWithKeyLog initializes a HTTP Transport with KeyLogWriter
func newTransportWithKeyLog(keyLog io.Writer) *http.Transport {
	transport := &http.Transport{
		TLSClientConfig: &gotls.Config{KeyLogWriter: keyLog},

		// Copy of http.DefaultTransport
		Proxy: http.ProxyFromEnvironment,
		DialContext: (&net.Dialer{
			Timeout:   30 * time.Second,
			KeepAlive: 30 * time.Second,
			DualStack: true,
		}).DialContext,
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
	}
	if err := http2.ConfigureTransport(transport); err != nil {
		panic(err)
	}
	return transport
}